// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: livesQuery.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLive = `-- name: CreateLive :one
INSERT INTO live (user_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_hash,   live_secret_encrypted, stream_broadcast_url_encrypted)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12
)
RETURNING live_id, user_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at
`

type CreateLiveParams struct {
	UserID                      pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
}

func (q *Queries) CreateLive(ctx context.Context, arg CreateLiveParams) (Live, error) {
	row := q.db.QueryRow(ctx, createLive,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.ScheduledStartTime,
		arg.ScheduledEndTime,
		arg.LiveAppName,
		arg.StreamName,
		arg.LiveSecretHash,
		arg.LiveSecretEncrypted,
		arg.StreamBroadcastUrlEncrypted,
	)
	var i Live
	err := row.Scan(
		&i.LiveID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretEncrypted,
		&i.LiveSecretHash,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLive = `-- name: DeleteLive :exec
DELETE FROM live
WHERE live_id = $1
`

func (q *Queries) DeleteLive(ctx context.Context, liveID int32) error {
	_, err := q.db.Exec(ctx, deleteLive, liveID)
	return err
}

const getLiveByID = `-- name: GetLiveByID :one
SELECT live_id, user_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name,live_secret_hash,live_secret_encrypted, stream_broadcast_url_encrypted,  created_at
FROM live
WHERE live_id = $1
`

type GetLiveByIDRow struct {
	LiveID                      int32
	UserID                      pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	CreatedAt                   pgtype.Timestamptz
}

func (q *Queries) GetLiveByID(ctx context.Context, liveID int32) (GetLiveByIDRow, error) {
	row := q.db.QueryRow(ctx, getLiveByID, liveID)
	var i GetLiveByIDRow
	err := row.Scan(
		&i.LiveID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretHash,
		&i.LiveSecretEncrypted,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
	)
	return i, err
}

const getLiveBySecretHashAppAndStream = `-- name: GetLiveBySecretHashAppAndStream :one
SELECT live_id, user_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name,live_secret_hash, live_secret_encrypted, stream_broadcast_url_encrypted, created_at
FROM live
WHERE stream_name = $1 AND live_secret_hash =  $2 AND live_app_name =  $3
`

type GetLiveBySecretHashAppAndStreamParams struct {
	StreamName     pgtype.Text
	LiveSecretHash pgtype.Text
	LiveAppName    pgtype.Text
}

type GetLiveBySecretHashAppAndStreamRow struct {
	LiveID                      int32
	UserID                      pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	CreatedAt                   pgtype.Timestamptz
}

func (q *Queries) GetLiveBySecretHashAppAndStream(ctx context.Context, arg GetLiveBySecretHashAppAndStreamParams) (GetLiveBySecretHashAppAndStreamRow, error) {
	row := q.db.QueryRow(ctx, getLiveBySecretHashAppAndStream, arg.StreamName, arg.LiveSecretHash, arg.LiveAppName)
	var i GetLiveBySecretHashAppAndStreamRow
	err := row.Scan(
		&i.LiveID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretHash,
		&i.LiveSecretEncrypted,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
	)
	return i, err
}

const getLiveWithStatusByID = `-- name: GetLiveWithStatusByID :one
SELECT
    l.live_id,
    l.user_id,
    l.title,
    l.description,
    l.start_time,
    l.end_time,
    l.scheduled_start_time,
    l.scheduled_end_time,
    l.live_app_name,
    l.stream_name,
    l.live_secret_hash,
    l.live_secret_encrypted, 
    l.stream_broadcast_url_encrypted, 
    l.created_at,
    l.updated_at,
    ls.status AS live_status
FROM live l
LEFT JOIN live_stats ls ON l.live_id = ls.live_id
WHERE l.live_id = $1
`

type GetLiveWithStatusByIDRow struct {
	LiveID                      int32
	UserID                      pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	LiveStatus                  pgtype.Text
}

func (q *Queries) GetLiveWithStatusByID(ctx context.Context, liveID int32) (GetLiveWithStatusByIDRow, error) {
	row := q.db.QueryRow(ctx, getLiveWithStatusByID, liveID)
	var i GetLiveWithStatusByIDRow
	err := row.Scan(
		&i.LiveID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretHash,
		&i.LiveSecretEncrypted,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LiveStatus,
	)
	return i, err
}

const getLiveWithUserDetails = `-- name: GetLiveWithUserDetails :one
SELECT     l.live_id,
    l.user_id,
    l.title,
    l.description,
    l.start_time,
    l.end_time,
    l.scheduled_start_time,
    l.scheduled_end_time,
    l.live_app_name,
    l.stream_name,
    l.live_secret_hash,
    l.live_secret_encrypted, 
    l.stream_broadcast_url_encrypted, 
    l.created_at,
    l.updated_at,
     u.first_name, 
     u.last_name, 
     u.email 
FROM live l 
JOIN users u ON l.user_id = u.user_id 
WHERE l.live_id = $1
`

type GetLiveWithUserDetailsRow struct {
	LiveID                      int32
	UserID                      pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	FirstName                   pgtype.Text
	LastName                    pgtype.Text
	Email                       string
}

func (q *Queries) GetLiveWithUserDetails(ctx context.Context, liveID int32) (GetLiveWithUserDetailsRow, error) {
	row := q.db.QueryRow(ctx, getLiveWithUserDetails, liveID)
	var i GetLiveWithUserDetailsRow
	err := row.Scan(
		&i.LiveID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretHash,
		&i.LiveSecretEncrypted,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Email,
	)
	return i, err
}

const getLivesByUserID = `-- name: GetLivesByUserID :many
SELECT live_id, user_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at FROM live WHERE user_id = $1 ORDER BY start_time DESC
`

func (q *Queries) GetLivesByUserID(ctx context.Context, userID pgtype.UUID) ([]Live, error) {
	rows, err := q.db.Query(ctx, getLivesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Live
	for rows.Next() {
		var i Live
		if err := rows.Scan(
			&i.LiveID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.ScheduledStartTime,
			&i.ScheduledEndTime,
			&i.LiveAppName,
			&i.StreamName,
			&i.LiveSecretEncrypted,
			&i.LiveSecretHash,
			&i.StreamBroadcastUrlEncrypted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOngoingLives = `-- name: GetOngoingLives :many
SELECT live_id, user_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at FROM live WHERE start_time <= CURRENT_TIMESTAMP AND (end_time IS NULL OR end_time > CURRENT_TIMESTAMP) ORDER BY start_time DESC
`

func (q *Queries) GetOngoingLives(ctx context.Context) ([]Live, error) {
	rows, err := q.db.Query(ctx, getOngoingLives)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Live
	for rows.Next() {
		var i Live
		if err := rows.Scan(
			&i.LiveID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.ScheduledStartTime,
			&i.ScheduledEndTime,
			&i.LiveAppName,
			&i.StreamName,
			&i.LiveSecretEncrypted,
			&i.LiveSecretHash,
			&i.StreamBroadcastUrlEncrypted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLive = `-- name: UpdateLive :one
UPDATE live
SET
  user_id = $1,
  title = $2,
  description = $3,
  start_time = $4,
  end_time = $5,
  scheduled_start_time = $6,
  scheduled_end_time = $7,
  live_app_name = $8,
  stream_name = $9,
  live_secret_hash = $10,
  live_secret_encrypted = $11,
  stream_broadcast_url_encrypted = $12,
  updated_at = current_timestamp
WHERE live_id = $13
RETURNING live_id, user_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at
`

type UpdateLiveParams struct {
	UserID                      pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	LiveID                      int32
}

func (q *Queries) UpdateLive(ctx context.Context, arg UpdateLiveParams) (Live, error) {
	row := q.db.QueryRow(ctx, updateLive,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.ScheduledStartTime,
		arg.ScheduledEndTime,
		arg.LiveAppName,
		arg.StreamName,
		arg.LiveSecretHash,
		arg.LiveSecretEncrypted,
		arg.StreamBroadcastUrlEncrypted,
		arg.LiveID,
	)
	var i Live
	err := row.Scan(
		&i.LiveID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretEncrypted,
		&i.LiveSecretHash,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
