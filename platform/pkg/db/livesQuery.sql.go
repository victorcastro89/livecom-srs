// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: livesQuery.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLive = `-- name: CreateLive :one
INSERT INTO live (account_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_hash,   live_secret_encrypted, stream_broadcast_url_encrypted)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12
)
RETURNING live_id, account_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at
`

type CreateLiveParams struct {
	AccountID                   pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
}

func (q *Queries) CreateLive(ctx context.Context, arg CreateLiveParams) (Live, error) {
	row := q.db.QueryRow(ctx, createLive,
		arg.AccountID,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.ScheduledStartTime,
		arg.ScheduledEndTime,
		arg.LiveAppName,
		arg.StreamName,
		arg.LiveSecretHash,
		arg.LiveSecretEncrypted,
		arg.StreamBroadcastUrlEncrypted,
	)
	var i Live
	err := row.Scan(
		&i.LiveID,
		&i.AccountID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretEncrypted,
		&i.LiveSecretHash,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLive = `-- name: DeleteLive :exec
DELETE FROM live
WHERE live_id = $1
`

func (q *Queries) DeleteLive(ctx context.Context, liveID int32) error {
	_, err := q.db.Exec(ctx, deleteLive, liveID)
	return err
}

const getLiveBySecretHashAppAndStream = `-- name: GetLiveBySecretHashAppAndStream :one
SELECT live_id, account_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name,live_secret_hash, live_secret_encrypted, stream_broadcast_url_encrypted, created_at
FROM live
WHERE stream_name = $1 AND live_secret_hash =  $2 AND live_app_name =  $3
`

type GetLiveBySecretHashAppAndStreamParams struct {
	StreamName     pgtype.Text
	LiveSecretHash pgtype.Text
	LiveAppName    pgtype.Text
}

type GetLiveBySecretHashAppAndStreamRow struct {
	LiveID                      int32
	AccountID                   pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	CreatedAt                   pgtype.Timestamptz
}

func (q *Queries) GetLiveBySecretHashAppAndStream(ctx context.Context, arg GetLiveBySecretHashAppAndStreamParams) (GetLiveBySecretHashAppAndStreamRow, error) {
	row := q.db.QueryRow(ctx, getLiveBySecretHashAppAndStream, arg.StreamName, arg.LiveSecretHash, arg.LiveAppName)
	var i GetLiveBySecretHashAppAndStreamRow
	err := row.Scan(
		&i.LiveID,
		&i.AccountID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretHash,
		&i.LiveSecretEncrypted,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
	)
	return i, err
}

const getLiveWithStatusByID = `-- name: GetLiveWithStatusByID :one
SELECT
    l.live_id,
    l.account_id,
    l.title,
    l.description,
    l.start_time,
    l.end_time,
    l.scheduled_start_time,
    l.scheduled_end_time,
    l.live_app_name,
    l.stream_name,
    l.live_secret_hash,
    l.live_secret_encrypted, 
    l.stream_broadcast_url_encrypted, 
    l.created_at,
    l.updated_at,
    ls.status AS live_status
FROM live l
LEFT JOIN live_stats ls ON l.live_id = ls.live_id
WHERE l.live_id = $1
`

type GetLiveWithStatusByIDRow struct {
	LiveID                      int32
	AccountID                   pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	LiveStatus                  pgtype.Text
}

func (q *Queries) GetLiveWithStatusByID(ctx context.Context, liveID int32) (GetLiveWithStatusByIDRow, error) {
	row := q.db.QueryRow(ctx, getLiveWithStatusByID, liveID)
	var i GetLiveWithStatusByIDRow
	err := row.Scan(
		&i.LiveID,
		&i.AccountID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretHash,
		&i.LiveSecretEncrypted,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LiveStatus,
	)
	return i, err
}

const getLivesByUserID = `-- name: GetLivesByUserID :many
SELECT live_id, account_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at FROM live WHERE account_id = $1 ORDER BY start_time DESC
`

func (q *Queries) GetLivesByUserID(ctx context.Context, accountID pgtype.UUID) ([]Live, error) {
	rows, err := q.db.Query(ctx, getLivesByUserID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Live
	for rows.Next() {
		var i Live
		if err := rows.Scan(
			&i.LiveID,
			&i.AccountID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.ScheduledStartTime,
			&i.ScheduledEndTime,
			&i.LiveAppName,
			&i.StreamName,
			&i.LiveSecretEncrypted,
			&i.LiveSecretHash,
			&i.StreamBroadcastUrlEncrypted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOngoingLives = `-- name: GetOngoingLives :many
SELECT live_id, account_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at FROM live WHERE start_time <= CURRENT_TIMESTAMP AND (end_time IS NULL OR end_time > CURRENT_TIMESTAMP) ORDER BY start_time DESC
`

func (q *Queries) GetOngoingLives(ctx context.Context) ([]Live, error) {
	rows, err := q.db.Query(ctx, getOngoingLives)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Live
	for rows.Next() {
		var i Live
		if err := rows.Scan(
			&i.LiveID,
			&i.AccountID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.ScheduledStartTime,
			&i.ScheduledEndTime,
			&i.LiveAppName,
			&i.StreamName,
			&i.LiveSecretEncrypted,
			&i.LiveSecretHash,
			&i.StreamBroadcastUrlEncrypted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedLivesByAccountId = `-- name: GetPaginatedLivesByAccountId :many
SELECT
    l.live_id,
    l.account_id,
    l.title,
    l.description,
    l.start_time,
    l.end_time,
    l.scheduled_start_time,
    l.scheduled_end_time,
    l.live_app_name,
    l.stream_name,
    l.live_secret_hash,
    l.live_secret_encrypted, 
    l.stream_broadcast_url_encrypted, 
    l.created_at,
    l.updated_at,
    ls.status AS live_status
FROM live l
JOIN live_stats ls ON l.live_id = ls.live_id
JOIN account ac ON l.account_id = ac.account_id
WHERE ac.account_id = $3::uuid 
ORDER BY l.scheduled_start_time DESC
LIMIT  $1  OFFSET   $2
`

type GetPaginatedLivesByAccountIdParams struct {
	Limit     int32
	Offset    int32
	AccountID pgtype.UUID
}

type GetPaginatedLivesByAccountIdRow struct {
	LiveID                      int32
	AccountID                   pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	LiveStatus                  pgtype.Text
}

func (q *Queries) GetPaginatedLivesByAccountId(ctx context.Context, arg GetPaginatedLivesByAccountIdParams) ([]GetPaginatedLivesByAccountIdRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedLivesByAccountId, arg.Limit, arg.Offset, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedLivesByAccountIdRow
	for rows.Next() {
		var i GetPaginatedLivesByAccountIdRow
		if err := rows.Scan(
			&i.LiveID,
			&i.AccountID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.ScheduledStartTime,
			&i.ScheduledEndTime,
			&i.LiveAppName,
			&i.StreamName,
			&i.LiveSecretHash,
			&i.LiveSecretEncrypted,
			&i.StreamBroadcastUrlEncrypted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LiveStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLive = `-- name: UpdateLive :one
UPDATE live
SET
  account_id = $1,
  title = $2,
  description = $3,
  start_time = $4,
  end_time = $5,
  scheduled_start_time = $6,
  scheduled_end_time = $7,
  live_app_name = $8,
  stream_name = $9,
  live_secret_hash = $10,
  live_secret_encrypted = $11,
  stream_broadcast_url_encrypted = $12,
  updated_at = current_timestamp
WHERE live_id = $13
RETURNING live_id, account_id, title, description, start_time, end_time, scheduled_start_time, scheduled_end_time, live_app_name, stream_name, live_secret_encrypted, live_secret_hash, stream_broadcast_url_encrypted, created_at, updated_at
`

type UpdateLiveParams struct {
	AccountID                   pgtype.UUID
	Title                       string
	Description                 pgtype.Text
	StartTime                   pgtype.Timestamp
	EndTime                     pgtype.Timestamp
	ScheduledStartTime          pgtype.Timestamp
	ScheduledEndTime            pgtype.Timestamp
	LiveAppName                 pgtype.Text
	StreamName                  pgtype.Text
	LiveSecretHash              pgtype.Text
	LiveSecretEncrypted         pgtype.Text
	StreamBroadcastUrlEncrypted pgtype.Text
	LiveID                      int32
}

func (q *Queries) UpdateLive(ctx context.Context, arg UpdateLiveParams) (Live, error) {
	row := q.db.QueryRow(ctx, updateLive,
		arg.AccountID,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.ScheduledStartTime,
		arg.ScheduledEndTime,
		arg.LiveAppName,
		arg.StreamName,
		arg.LiveSecretHash,
		arg.LiveSecretEncrypted,
		arg.StreamBroadcastUrlEncrypted,
		arg.LiveID,
	)
	var i Live
	err := row.Scan(
		&i.LiveID,
		&i.AccountID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.ScheduledStartTime,
		&i.ScheduledEndTime,
		&i.LiveAppName,
		&i.StreamName,
		&i.LiveSecretEncrypted,
		&i.LiveSecretHash,
		&i.StreamBroadcastUrlEncrypted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
